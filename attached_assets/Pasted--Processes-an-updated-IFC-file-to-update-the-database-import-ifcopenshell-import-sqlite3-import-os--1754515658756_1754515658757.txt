# Processes an updated IFC file to update the database
import ifcopenshell
import sqlite3
import os
from datetime import datetime

# Define the path to the updated IFC file
# Replace with the actual path to your updated IFC file
updated_file_path = "SuD_Aussparungen.ifc"
# Define the database file name
db_filename = 'SuD_Datenbank.db'

conn = None

try:
    # Connect to the SQLite database
    conn = sqlite3.connect(db_filename)
    c = conn.cursor()

    # Create the table if it doesn't exist
    # Added 'deletion_date' column
    c.execute('''CREATE TABLE IF NOT EXISTS ifc_objects
                 (guid TEXT, filename TEXT, added_timestamp TEXT, status TEXT DEFAULT 'active',
                  approval_architect BOOLEAN DEFAULT FALSE, approval_structure BOOLEAN DEFAULT FALSE,
                  deletion_date TEXT)''')

    # --- 1. Extract data from the updated IFC file and get creation date (ONLY from FILE_NAME header) ---
    updated_extracted_data = [] # List to hold GUIDs and filenames from the updated IFC
    updated_ifc_filename = os.path.basename(updated_file_path)
    ifc_creation_date = None # Initialize as None, will only be set if found in FILE_NAME header

    try:
        updated_ifc_file = ifcopenshell.open(updated_file_path)

        # Attempt to extract creation date ONLY from the FILE_NAME header
        ifc_header = updated_ifc_file.header
        if ifc_header and hasattr(ifc_header, 'file_name') and hasattr(ifc_header.file_name, 'time_stamp'):
            # The time_stamp is usually a string, might include timezone info or milliseconds
            timestamp_str = str(ifc_header.file_name.time_stamp) # Ensure it's a string
            try:
                # Attempt to parse various common datetime formats, including potential timezone info
                # We'll try parsing the part before any potential '+' or '.' for timezone/milliseconds
                datetime_part = timestamp_str.split('+')[0].split('.')[0]
                timestamp_obj = datetime.strptime(datetime_part, '%Y-%m-%dT%H:%M:%S')
                ifc_creation_date = timestamp_obj.strftime('%y%m%d')
                print(f"Found creation date in FILE_NAME header: {ifc_creation_date}")
            except ValueError:
                print(f"Warning: Could not parse timestamp format from FILE_NAME: {timestamp_str}. IFC creation date will not be used.")
                ifc_creation_date = None # Ensure it's None if parsing fails
        else:
             print("Warning: FILE_NAME header or time_stamp not found. IFC creation date will not be used.")
             ifc_creation_date = None


        updated_provision_for_void = updated_ifc_file.by_type("IfcVirtualElement")

        if updated_provision_for_void:
            for element in updated_provision_for_void:
                updated_extracted_data.append((element.GlobalId, updated_ifc_filename))
        else:
            print(f"No IfcVirtualElement found in the updated file: {updated_file_path}")

    except FileNotFoundError:
        print(f"Error: Updated file not found at {updated_file_path}")
        # Exit the script if the file is not found
        exit()
    except Exception as e:
        print(f"An error occurred during extraction from the updated file: {e}")
        # Exit the script on other extraction errors
        exit()

    # Create a set of GUIDs from the updated IFC data for efficient lookup
    updated_guids = set([item[0] for item in updated_extracted_data])

    # --- 2. Query existing data from the database ---
    existing_data = {} # Dictionary to hold existing GUIDs and their statuses for the filename
    try:
        c.execute("SELECT guid, status FROM ifc_objects WHERE filename = ?", (updated_ifc_filename,))
        for row in c.fetchall():
            existing_data[row[0]] = row[1]

        print(f"Found {len(existing_data)} existing objects in the database for filename '{updated_ifc_filename}'.")

    except sqlite3.Error as e:
        print(f"Database error during query: {e}")
        # Exit the script on database errors
        exit()


    # --- 3. Identify deleted objects and update their status and deletion date ---
    # Only attempt to identify and mark deleted objects if there is existing data for this filename
    if existing_data:
        deleted_guids = []
        # Use the extracted IFC creation date for deletion date if available, otherwise use current date
        deletion_timestamp = ifc_creation_date if ifc_creation_date else datetime.now().strftime('%y%m%d')

        for guid, status in existing_data.items():
            # If a GUID exists in the database but is NOT in the updated IFC data, and its status is 'active'
            if guid not in updated_guids and status == 'active':
                deleted_guids.append(guid)

        if deleted_guids:
            try:
                # Update the status to 'deleted' and set the deletion_date using the IFC creation date if available
                # If ifc_creation_date is None, the deletion_date will be set to None (or its default if defined in schema)
                c.executemany('UPDATE ifc_objects SET status = "deleted", deletion_date = ? WHERE guid = ?', [(deletion_timestamp, guid) for guid in deleted_guids])
                print(f"Successfully marked {len(deleted_guids)} objects as 'deleted' in the database.")
            except sqlite3.Error as e:
                print(f"Database error during deletion update: {e}")
                # Exit the script on database errors
                exit()
        else:
            print("No objects found in the database to mark as 'deleted' for this filename.")
    else:
        print("No existing data found for this filename, skipping deletion check.")


    # --- 4. Identify and insert new objects ---
    existing_guids_set = set(existing_data.keys()) # Use a set for efficient lookup
    new_objects_to_add = []
    # Use the extracted IFC creation date for added_timestamp if available, otherwise use current date
    added_timestamp = ifc_creation_date if ifc_creation_date else datetime.now().strftime('%y%m%d')


    for guid, filename in updated_extracted_data:
        # If a GUID from the updated IFC data is NOT in the existing database GUIDs
        if guid not in existing_guids_set:
            # Append the new object details with 'active' status and the IFC creation date if available, deletion_date is None
            new_objects_to_add.append((guid, filename, added_timestamp, 'active', False, False, None))

    if new_objects_to_add:
        try:
            c.executemany('INSERT INTO ifc_objects VALUES (?,?,?,?,?,?,?)', new_objects_to_add)
            print(f"Successfully added {len(new_objects_to_add)} new objects to the database.")
        except sqlite3.Error as e:
            print(f"Database error during new object insertion: {e}")
            # Exit the script on database errors
            exit()
    else:
        print("No new objects found in the updated IFC file to add to the database.")

    # --- 5. Commit changes ---
    conn.commit()

except sqlite3.Error as e:
    print(f"Database error: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

finally:
    if conn:
        conn.close()